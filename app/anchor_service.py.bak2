import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

def cli_perform_anchor(payload, context=None):
    """
    Temporary stub for CLI anchor function.
    Replace with real import once integration verified.
    """
    logger.info("cli_perform_anchor: stub called with payload=%s, context=%s", payload, context)
    return {"anchor_id": "stub-ANCHOR-000", "status": "ok"}

def perform_anchor_sync(payload, user_ctx):
    """
    Synchronous wrapper that calls the CLI anchor function (stub for now).
    Returns the CLI result dict.
    """
    logger.info("perform_anchor_sync: starting anchor for payload=%s user=%s", payload, user_ctx.get("user_id") if isinstance(user_ctx, dict) else user_ctx)
    result = cli_perform_anchor(payload, context=user_ctx)
    logger.info("perform_anchor_sync: finished anchor result=%s", result)
    return result

import uuid
from threading import Thread

def start_anchor_job(payload, user_ctx):
    """
    Minimal async wrapper â€” creates a job ID, starts a background thread, and returns immediately.
    """
    job_id = str(uuid.uuid4())
    logger.info("start_anchor_job: enqueuing job %s for payload=%s", job_id, payload)

    def _run():
        try:
            logger.info("start_anchor_job: worker starting job %s", job_id)
            cli_perform_anchor(payload, context=user_ctx)
            logger.info("start_anchor_job: worker finished job %s", job_id)
        except Exception as e:
            logger.exception("start_anchor_job: job %s failed: %s", job_id, e)

    Thread(target=_run, daemon=True).start()
    return {"job_id": job_id, "status": "queued"}


# --- Test helpers & small store API (appended automatically) -------------------
import json
from pathlib import Path as _Path
import time as _time

# file-backed state variables (tests patch these)
_VAR_DIR = _Path("var")
_ANC_FILE = _VAR_DIR / "anchors.json"
_JOB_FILE = _VAR_DIR / "jobs.json"

def _ensure_store():
    \"\"\"Ensure var/, anchors.json and jobs.json exist.\"\"\"
    _VAR_DIR.mkdir(parents=True, exist_ok=True)
    if not _ANC_FILE.exists():
        _ANC_FILE.write_text(json.dumps({}))
    if not _JOB_FILE.exists():
        _JOB_FILE.write_text(json.dumps({}))

def _read_store(path):
    try:
        return json.loads(path.read_text())
    except Exception:
        return {}

def _write_store(path, data):
    path.write_text(json.dumps(data, indent=2))

# API expected by tests:
def record_anchor(resource_id: str, anchor_id: str):
    \"\"\"Record an anchor_id for resource_id into anchors.json\"\"\"
    _ensure_store()
    anchors = _read_store(_ANC_FILE)
    anchors[resource_id] = anchor_id
    _write_store(_ANC_FILE, anchors)
    return True

def get_anchor_for_resource(resource_id: str):
    \"\"\"Return anchor_id or None\"\"\n    _ensure_store()
    anchors = _read_store(_ANC_FILE)
    return anchors.get(resource_id)

def set_job_status(job_id: str, status: str, resource_id: str=None):
    \"\"\"Set or update a job entry in jobs.json\"\"\"
    _ensure_store()
    jobs = _read_store(_JOB_FILE)
    now = int(_time.time())
    entry = jobs.get(job_id, {})
    entry.update({
        "status": status,
        "resource_id": resource_id or entry.get("resource_id"),
        "updated_at": now,
    })
    if not entry.get("created_at"):
        entry["created_at"] = now
    jobs[job_id] = entry
    _write_store(_JOB_FILE, jobs)
    return entry

def get_job_status(job_id: str):
    \"\"\"Return job entry dict or None\"\"\"
    _ensure_store()
    jobs = _read_store(_JOB_FILE)
    return jobs.get(job_id)
